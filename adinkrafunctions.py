# -*- coding: utf-8 -*-
"""
Created on Thu Oct  4 04:39:05 2018

@author: Peter
"""

import numpy as np    
import itertools
import random
import collections
import matplotlib.pyplot as plt
import matplotlib.mlab as mlab
import timeit
import matplotlib as mpl
import csv
from time import gmtime, strftime

mpl.rcParams.update(mpl.rcParamsDefault)
mpl.rcParams.update({'font.size': 22})

# generates N! matrices whose row and column vectors are orthogonal to one another
def makePermuteMatrices(row_size=4,column_size=4):
    rows, row_permutations, matrices = [],[],[]
    
    # creates rows where one element is 1 and the others are 0 because the rows are orthogonal vectors
    for i in range(0,column_size):
        new_row = np.zeros(column_size)
        new_row[i] = 1
        rows.append(new_row)
        
    # creates N x N matrices by permuting the rows
    row_permutations = list(itertools.permutations(rows,row_size))
    for permutations in row_permutations:
        matrices.append(np.stack(permutations))
    print("Generated {} permutation matrices!".format(len(matrices)))
    return matrices, rows

# generates 2^N matrices that change the signs of permuted matrices
def makeSignedMatrices(dim=4):
    matrices = []
    # creates N-entry rows with every possible arrange of 1s and -1s
    ones = [1, -1]    
    rows = list(itertools.product(ones, repeat=dim))
    
    #converts rows into the diagonal elements of N x N matrices
    for row in rows:
        row = np.array(row) 
        matrices.append(np.diag(row))
    print("Generated {} sign matrices!".format(len(matrices)))
    return matrices, rows

# generates list of matrix products from two lists of matrices
def makeProductMatrices(matrices_a, matrices_b):
    new_matrices = []
    for matrix_a in matrices_a:
        for matrix_b in matrices_b:
            new_matrices.append(np.matmul(matrix_a,matrix_b))
    print("Generated {} permuted and signed matrices!".format(len(new_matrices)))
    return new_matrices

# generates a random list from a pool of N matrices where each item (i.e. "bin") in the list consists of M matrices
def makeRandomList(list_size, matrices_pool, bin_size = 4):
    matrices_list, bin_matrices = [], []
    for x in range(0,list_size):
        for x in range(0,bin_size):
            bin_matrices.append(random.choice(matrices_pool))
        matrices_list.append(bin_matrices)
        bin_matrices = []
    print("Generated a list of {} bins with {} randomly chosen matrices per bin!".format(len(matrices_list),bin_size))
    return matrices_list

# makes a "blueprint" for building a 4 x 4 matrix whose rows and columns are orthogonal
def makeBlueprint(matrix):
    decomposition = np.vsplit(matrix,matrix.shape[0])
    blueprint_list = [] 
    for row in decomposition:
        # convert index of non-trivial element to a "blueprint" number from 1 to N where N is the column number
        # the row number is determined by the position of the blueprint number along the row
        # sign of non-trivial element is preserved by the sign of the blueprint number

        #print(np.array(np.nonzero(row)))
        nonzero_index = np.nonzero(row)[1]
        nonzero_sign = np.sign(row[0,nonzero_index])
        blueprint_index = int((abs(nonzero_index + 1))) * int(nonzero_sign)
        blueprint_list.append(blueprint_index)
    blueprint_num = np.array(blueprint_list)
    return blueprint_num

def makeBlueprintList(matrix_bins):
    blueprint_list, row_list = [], []
    for matrix_bin in matrix_bins:
        for matrix in matrix_bin:
            blueprint = makeBlueprint(matrix)
            row_list.append(blueprint)
        blueprint_list.append(np.stack(row_list))
        row_list = []
    return blueprint_list

# converts blueprint to matrix
def convertBlueprintMatrix(blueprint, axes = 1, columns = 0):
    output_rows = []
    abs_blueprint = np.abs(blueprint)    
    if columns == 0:
        column_num = np.amax(abs_blueprint)
    else:
        column_num = columns
    for index in range(0,column_num):
        new_row = np.zeros(column_num)    
        if axes == 2:
            row_pos = abs_blueprint[0,index] - 1
            entry_value = blueprint[0,index]/abs_blueprint[0,index] 
        else:
            row_pos = abs_blueprint[index] - 1
            entry_value = blueprint[index]/abs_blueprint[index]    
        new_row[row_pos]= entry_value
        output_rows.append(new_row)
    output_matrix = np.stack(output_rows)
   #print("The matrix generated by the blueprint {} for {} columns is: \n {}".format(blueprint, column_num, output_matrix))
    return output_matrix

# converts blueprint matrix to a bin of multiple signed and permuted matrices
def convertBlueprintBin(blueprint_matrix):
    decomposition = np.vsplit(blueprint_matrix,blueprint_matrix.shape[0])
    matrix_bin = []
    for blueprint in decomposition:
        output_matrix = convertBlueprintMatrix(blueprint, axes =2)
        matrix_bin.append(output_matrix)
    return matrix_bin

def blueprintMulti(row1, row2):
    product = []
    for index in range(0,len(row1)):
        i = index - 1
        j = abs(row1[i])
        product.append((row1[i]*row2[j-1])/j)
        
#    product = [(row1[i-1]*row2[abs(row1[i-1])-1])/abs(row1[i]) for i, numbers in enumerate(row1)]
    return product

def blueprintTransp(row):
    transp = np.zeros(len(row))
    for index in range(0,len(row)):
        i = index - 1
        transp[abs(row[i])-1] = row[i]
    return transp

def commute(matrix_1, matrix_2):
    commute_matrix = np.subtract(np.matmul(matrix_1,matrix_2),np.matmul(matrix_2,matrix_1))
    return commute_matrix

def anticommute(matrix_1, matrix_2):
    anticommute_matrix = np.add(np.matmul(matrix_1,matrix_2),np.matmul(matrix_2,matrix_1))
    return anticommute_matrix

def holoraumy(matrix_1, matrix_2):
    holoraumy_matrix = np.subtract(0.5*np.matmul(np.transpose(matrix_1),matrix_2),0.5*np.matmul(np.transpose(matrix_2),matrix_1))
    return holoraumy_matrix

def reducedGadget(bin_1, bin_2, norm = -0.25):
    if len(bin_1) != len(bin_2):
        print("Lengths of bins do not match! Please fix this mistake.")
    else:
        terms = []
        for index, matrix in enumerate(bin_1):
            product_trace = norm*np.trace(np.matmul(bin_1[index],bin_2[index]))
            terms.append(product_trace)
        gadget = np.sum(np.array(terms))
        #print("Product trace terms: {}".format(terms))
        #print("Reduced gadget: {} ".format(gadget))
    return gadget
            
# generates a list where each bin contains all possible holoraumy matrices, e.g. if there are originally 4 matrices in each bin, then 16 holoraumy matrices will be created per bin 
def makeHoloraumyList(bin_list, condition_title=""):
    holoraumy_list, holoraumy_matrices = [], []
    bin_size = len(bin_list[0])
    matrix_number = list(range(0,bin_size))
    possible_matrix_pairs = list(itertools.product(matrix_number, repeat=2))
    for matrix_bin in bin_list:
        #print("Matrices in bin {}: \n {}". format(index,matrices_bin))
        for pairs in possible_matrix_pairs:
            matrix_1, matrix_2 = matrix_bin[pairs[0]], matrix_bin[pairs[1]]
            holoraumy_matrix = holoraumy(matrix_1, matrix_2)
            holoraumy_matrices.append(holoraumy_matrix)
        holoraumy_list.append(holoraumy_matrices)
        holoraumy_matrices = []  
    print("Generated a list of {} bins with {} holoraumy matrices per bin{}!".format(len(holoraumy_list),len(holoraumy_list[0]), condition_title))
    return holoraumy_list

def makeGadgetList(holoraumy_list, base_bin = 0, every_bin = False, norm = -0.25):
    gadget_values = []
    number_of_bins= len(holoraumy_list)  
    if every_bin == True:
        bin_number = list(range(0,number_of_bins))
        possible_bin_pairs = list(itertools.combinations_with_replacement(bin_number, 2))
        print("Calculating gadgets for every possible {} pairs of bins!".format(len(possible_bin_pairs)))   
        for pairs in possible_bin_pairs:
            bin_A, bin_B = holoraumy_list[pairs[0]],holoraumy_list[pairs[1]]
            random_gadget = reducedGadget(bin_A, bin_B, norm = norm)
            gadget_values.append(random_gadget)
    else:
        print("Calculating gadgets with bin {} as the base bin!".format(base_bin))
        for index, holoraumy_matrix in enumerate(holoraumy_list):
            bin_1, bin_2 = holoraumy_list[base_bin], holoraumy_list[index]
            random_gadget = reducedGadget(bin_1, bin_2, norm = norm)
            gadget_values.append(random_gadget)
    return gadget_values

# applies BC4 constraint after being given a list of quartets
def makeBC4list(bin_list, matrix_pool, base_bin = 0):
    pool_size = len(matrix_pool)
    BC4_list, products_list = [], []
    for index in range(0,len(bin_list)):
        for matrix in bin_list[base_bin]:
            matrix_product = np.matmul(matrix, matrix_pool[index % pool_size])
            products_list.append(matrix_product) 
        BC4_list.append(products_list)    
        products_list = []
    print("Generated a list of {} bins with {} BC4 matrices per bin!".format(len(BC4_list),len(BC4_list[0])))
    return BC4_list

def makeBC4(quartet_bin, matrix_pool):
    BC4_list, products_list = [], []
    for index in range(0,len(matrix_pool)):
        for matrix in quartet_bin:
            matrix_product = np.matmul(matrix, matrix_pool[index])
            products_list.append(matrix_product)
        BC4_list.append(products_list)
        products_list = []
    print("Generated a list of {} bins with {} BC4 matrices per bin!".format(len(BC4_list),len(BC4_list[0])))
    return BC4_list

# print out eithera bin of matrices or list of bins in a cleaner format
def prettyPrint(matrices_list, title = "", nested = True):
    # printing arrays in nested lists
    if nested == True:
        for index, bins in enumerate(matrices_list):
            print("Bin {}: \n".format(index+1))
            for matrix in bins:
                print("{} \n".format(matrix))
        # printing arrays in non-nested lists
    else:
        for  index, matrix in enumerate(matrices_list):
            print("Matrix {}: \n {}".format(index+1, matrix))

def checkComplete(bin_of_matrices, report = False):
    sum_matrix = sum(bin_of_matrices) 
    if 0 not in sum_matrix:
        is_complete = True
    else:
        is_complete = False
    if report == True:
        print("Sum of matrices: \n {}".format(sum_matrix))
        if is_complete == True:
            print("The quartet satisfies the completeness constraint.")
        else:
            print("The quartet does not satisfy the completeness constraint.")
    return is_complete

def makeCompleteList(bin_list):
    complete_list = []
    for matrix_bin in bin_list:
        if checkComplete(matrix_bin) == True:
            complete_list.append(matrix_bin)
    print("There are {} out of {} bins that satisfy the completeness condition!".format(len(complete_list),len(bin_list)))
    return complete_list
 
def checkAdinkra(matrix_bin, possible_matrix_pairs, bin_size = 4, report = False):
    is_adinkra = False 
    
    # generates every possible pair-wise combination if not previously done
    if len(possible_matrix_pairs) == 0:
        matrix_number = list(range(0,bin_size))
        possible_matrix_pairs = list(itertools.product(matrix_number, repeat=2))
        
    # checks if adinkra conditions (completeness + well-dashedness)are satsified
    for pairs in possible_matrix_pairs:
        if pairs[0] != pairs[1]:
            matrix_1, matrix_2 = matrix_bin[pairs[0]], matrix_bin[pairs[1]]
            dash_matrix = np.add(np.matmul(np.transpose(matrix_1),matrix_2),np.matmul(np.transpose(matrix_2),matrix_1))
            #print("Dashing matrix for pair {} is: \n {}".format(pairs, dash_matrix))
            if np.all(dash_matrix==0):
                is_adinkra = True
            else:
                is_adinkra = False
                if report == True:
                    print("The quartet does NOT correspond to an adinkra!")
                return is_adinkra
    if report == True:
        print("The quartet does correspond to an adinkra!")
    return is_adinkra

def makeAdinkraList(bin_list, bin_size = 4):
    adinkra_list = []
    matrix_number = list(range(0,bin_size))
    matrix_pairs = list(itertools.product(matrix_number, repeat=2))
    for matrix_bin in bin_list:
        if checkAdinkra(matrix_bin, matrix_pairs, bin_size) == True:
            adinkra_list.append(matrix_bin)
    print("There are {} out of {} bins that satisfy the adinkra condition!".format(len(adinkra_list),len(bin_list)))
    return adinkra_list

def findSquares(coordinates, squares_dict):
    squares = []
    
    # generates combinations of coordinates if there are no pre-existing ones
    if len(squares_dict) == 0:
        squares_dict = getSquaresDict(4, 8)
    
    possible_vertices_indices = squares_dict[len(coordinates)]
    
    for vertices_indices in possible_vertices_indices:
        vertices_coordinates = [coordinates[vertices_indices[0]],coordinates[vertices_indices[1]], coordinates[vertices_indices[2]], coordinates[vertices_indices[3]]]
        s_vertices = sorted(vertices_coordinates, key=lambda tup: tup[0])
        point1, point2, point3, point4 = s_vertices[0], s_vertices[1], s_vertices[2], s_vertices[3]
        
        # check if vertices satisfies definition for rectangle
        if point1[0] == point2[0] and point3[0] == point4[0] and point1[1] == point3[1] and point2[1] == point4[1]:
            squares.append(vertices_coordinates) 
        
        # if there are 8 coordinates after filtering, there can be at most 2 cycles
        if len(coordinates) == 8 and len(squares) == 2:
            break
        
        #if there are less than 8, then there can be at most 1
        if len(coordinates) <= 7 and len(squares) == 1:
            break
    return squares

# filters out coordinates that cannot be vertices of a square to reduce run time
def filterSquare(coordinates, bin_size=4):
    # list of coordinate tuples is split into separate lists of row axis values and column axis values
    coord1, coord2 = zip(*coordinates)
    coord1, coord2 = list(coord1), list(coord2)
    no_unique_found = 0
    counts = collections.Counter(coord1)
    while True:
        for i in range(0,bin_size-1):
            # if there were a rectangle, an even number of vertices would exist along a row or column
            # there can never be three or more vertices along a row or column due to the orthogonality of the signed permutation matrices
            # therefore vertices that appear only once along a row or column can never be part of a rectangle, which can be filtered out
            if counts[i] == 1: 
                try:
                    rem_index = coord1.index(i)
                    coord1.pop(rem_index)
                    coord2.pop(rem_index)
                    no_unique_found = 0
                    counts = collections.Counter(coord1)
                except:
                    pass  
        no_unique_found = no_unique_found + 1
        if no_unique_found == bin_size - 1:
            break
    new_coord = list(zip(coord1, coord2))
    if len(new_coord) % 2 != 0:
        print("Error: Length of coordinates list is odd ({} coordinates). Filtering should produce even number of coordinates.".format(len(new_coord)))
    return new_coord
          

def checkDashingOnly(matrix_1, matrix_2, squares_dict = [], filtering = True, max_2color_cycles = 2, row_num = 4, col_num =4):
    # generates combinations of coordinates if there are no pre-existing ones
    if len(squares_dict) == 0:
        squares_dict = getSquaresDict(4, 4*max_2color_cycles) # the maximum number of cycles for two colors is 2 for 4x4 matrices and 4 for 8x8 matrices
        
    # add mattrices to check for rectangles that represent potential cycles
    sum_matrix = np.add(matrix_1, matrix_2)
    coordinates, values = [], []
    for j in range(0,col_num):
        for i in range (0,row_num):
            if abs(sum_matrix[i,j]) == 1:
                coordinates.append((i,j))
    square_count = 0
    if not coordinates:
        return square_count
    
    # if there are less than 4 non-zero elements, and since a cycle must consist of 4 non-zero elements, then there must be no cycles
    if np.count_nonzero(sum_matrix) < 4:
        return square_count
        #print("The dashing is not satisfied!")
        
    # filtering only works for 4 x 4 matrices
    if filtering == True: 
        filter_coordinates = filterSquare(coordinates)
        squares = findSquares(filter_coordinates, squares_dict)
    else:
        squares = findSquares(coordinates, squares_dict)
    for square in squares:
        for point in square:
            values.append(sum_matrix[point[0], point[1]])
        if values.count(1) == 3 or values.count(-1) == 3:
            #print("The dashing is not satisfied!")
            square_count += 1
            values = []
        # checks for poorly dashed cycles    
        if values.count(1) == 2 or values.count(-1) == 2 or values.count(1) == 4 or values.count(-1) == 4:
            square_count = -1
            break
    #print("Square count is {}".format(square_count))
    return square_count
                    
def checkDashingOnlyBin(matrix_bin, possible_matrix_pairs=[], bin_size = 4, squares_dict = []):
    square_count, count_each_pair = 0, []
    
    # generates combinations of coordinates there are no pre-existing ones
    if len(possible_matrix_pairs) == 0:
        matrix_number = list(range(0,bin_size))
        possible_matrix_pairs = list(itertools.combinations(matrix_number, 2))
    if len(squares_dict) == 0:
        squares_dict = getSquaresDict(4, 8)
    for pairs in possible_matrix_pairs:
        matrix_1, matrix_2 = matrix_bin[pairs[0]], matrix_bin[pairs[1]]
        dash_status = checkDashingOnly(matrix_1, matrix_2, squares_dict)
        if dash_status == -1:
            square_count = 0
            break
        square_count = square_count + dash_status
        count_each_pair.append(dash_status)
    counts_each = np.array(count_each_pair)
    dashing = False
    if len(counts_each[counts_each >= 1]) == 6:
        dashing = True
    #print("Total square count is {}".format(square_count))
    #print("Number of cycles for each pair is {}".format(count_each_pair))
    return square_count, dashing

def getSquaresDict(min_coord_count, max_coord_count):
    coordinates_indices = []
    for index in range(0,min_coord_count+1):
        coordinates_number = list(range(0,max_coord_count-index))
        coordinates_indices.append((len(coordinates_number), coordinates_number))
    possible_squares_indices = []
    for coordinate_index in coordinates_indices:
        coordinate_count, possible_coordinates = coordinate_index[0], coordinate_index[1]
        possible_indices_groups = list(itertools.combinations(possible_coordinates,4))
        possible_squares_indices.append([coordinate_count, possible_indices_groups])
    possible_squares_dict = dict(possible_squares_indices)
    return possible_squares_dict
    
def makeDashingOnlyList(matrix_list, bin_size = 4):
    # initialize list of lists
    dashed_list1, dashed_list2, dashed_list3, dashed_list4, dashed_list5, dashed_list6, dashed_list7, dashed_list8, dashed_list9, dashed_list10, dashed_list11, dashed_list12 = [], [], [], [], [], [], [], [], [], [], [], []   
     
    # generates combinations of pairs of matrices out of the quartets, i.e. 4 choose 2
    matrix_number = list(range(0,bin_size))
    matrix_pairs = list(itertools.combinations(matrix_number, 2))
    
    # genreates combinations of indices for rectangle coordinates to be used in detecting twoc-oolor cycles, i.e. 8 choose 4 if there are 8 coordinates
    squares_dict = getSquaresDict(4, 8)
    
    for matrix_bin in matrix_list:
        dash_status = checkDashingOnlyBin(matrix_bin, matrix_pairs,bin_size, squares_dict)
        if dash_status[0] == 1:
            dashed_list1.append(matrix_bin)
        if dash_status[0] == 2:
            dashed_list2.append(matrix_bin)
        if dash_status[0] == 3:
            dashed_list3.append(matrix_bin)
        if dash_status[0] == 4:
            dashed_list4.append(matrix_bin)
        if dash_status[0] == 5:
            dashed_list5.append(matrix_bin)
        if dash_status[0] == 6:
            dashed_list6.append(matrix_bin)
        if dash_status[0] == 7:
            dashed_list7.append(matrix_bin)
        if dash_status[0] == 8:
            dashed_list8.append(matrix_bin)
        if dash_status[0] == 9:
            dashed_list9.append(matrix_bin)
        if dash_status[0] == 10:
            dashed_list10.append(matrix_bin)
        if dash_status[0] == 11:
            dashed_list11.append(matrix_bin)
        if dash_status[0] == 12:
            dashed_list12.append(matrix_bin)
    dashed_lists = [dashed_list1, dashed_list2, dashed_list3, dashed_list4, dashed_list5, dashed_list6, dashed_list7, dashed_list8, dashed_list9, dashed_list10, dashed_list11, dashed_list12]
    return dashed_lists

# calculates average and standard deviation, then plots histogram of frequency data
def fitFrequency(fig, data, normed = False, fit = False, xlim = 0, ylim = 0, title = "", xlabel = "", ylabel ="", num_bins =  100, subplot_num = [1,1,1]):
    subplot_row, subplot_column, subplot_position = subplot_num[0], subplot_num[1], subplot_num[2]
    ax = fig.add_subplot(subplot_row,subplot_column,subplot_position)
    if normed == True:
        weights = np.ones_like(data)/float(len(data))
        n, bins, patches = ax.hist(data, num_bins, weights=weights, facecolor='b')
    else:
        n, bins, patches = ax.hist(data, num_bins, facecolor='b')
    average, stdev = np.mean(data), np.sqrt(np.var(data))
    
    print("{} >>> Average: {} Standard deviation: {}".format(title, average, stdev))
    
    ax.set_title(title)
    ax.set_xlabel(xlabel)
    ax.set_ylabel(ylabel)
    if xlim != 0:
        ax.set_xlim((xlim))
    if ylim != 0:
        ax.set_ylim(ylim)
        
    # fits data and draws curve    
    if fit== True:
        y = mlab.normpdf( bins, average, stdev)
        ax.plot(bins, y, 'r--', linewidth=1)
    fig.tight_layout()

def saveBinList(matrix_list, save_dest='quartets_list.npz'):
    blueprints = makeBlueprintList(matrix_list)
    np.savez(save_dest, *blueprints)
        
def loadBinList(save_loc='quartets_list.npz'):
    bin_list = []
    container = np.load(save_loc)
    blueprints = [container[key] for key in container]
    for blueprint in blueprints:
        matrix_bin = convertBlueprintBin(blueprint)
        bin_list.append(matrix_bin)
    return bin_list